function cloneTable(source)
   --[[ Returns a copy of the table, using shallow copies.
   --]]

   local newTable = {}

   for i, item in ipairs(source) do
      table.insert(newTable, item)
   end

   return newTable
end

local TableUtility = {}
function TableUtility:keys(source)
  -- [[ Returns an indexed table where the values are the keys of source.
  -- ]]

  local result = {}
  for key, value in pairs(source) do
     table.insert(result, key)
  end

  return result
end

function TableUtility:keyCount(source)
  -- [[ Returns the number of keys in this indexed table.
  -- ]]

  local count = 0
  for key, value in pairs(source) do
     count = count + 1
  end

  return count
end

function TableUtility:size(source)
  -- Alias for keyCount
  return TableUtility:keyCount(source)
end

function TableUtility:map(source, map_func)
  -- Return a new table, generated by applying func to each value in the source.

  local result = {}

  for key, value in ipairs(source) do
    local mapped_value = map_func(key, value, source)
    table.insert(result, mapped_value)
  end

  return result
end

function TableUtility:filter(source, filter_func)
  -- [[ Return a new table. Call filter_func on each item in the source
  --]] and keep only those that return truthy values.

  local result = {}

  for key, value in ipairs(source) do
    local filter_value = filter_func(key, value, source)
    if filter_value then
      table.insert(result, value)
    end
  end

  return result
end

function TableUtility:pluck(source, key_to_pluck)
  --[[ Return a table of values extracted from the source, based on the key.
  ]]
  local plucker = function(key, value, list)
    return value[key_to_pluck]
  end

  return TableUtility:map(source, plucker)
end

function TableUtility:sum(source, accumulator, start_value)
  --[[ Return a single value by adding each value in the source table.
  ]]
  accumulator = accumulator or nil
  local sum = start_value
  if not accumulator then
    sum = 0
  end

  for key, value in ipairs(source) do
    if accumulator then
      sum = accumulator(sum, value)
    else
      sum = sum + value
    end
  end

  return sum
end

function TableUtility:each(source, action)
  --[[ Perform the action on each element in the source.

  The action will be a function that accepts 3 parameters: The key, the value, and the source.
  ]]

  for key, value in ipairs(source) do
    action(key, value, source)
  end
end

function TableUtility:listcomp(source, postprocess, filter)
  --[[ Perform a Python-style list comprehension on the source.
  Filter the source with filter as the function.
  Each item that is true will have Postprocess applied.
  ]]

  local filtered_items = TableUtility:filter(source, filter)
  local postprocessed_items = TableUtility:map(filtered_items, postprocess)
  return postprocessed_items
end

function TableUtility:all(source, predicate)
  --[[ Tests all of the items in the source are truthy.
  Predicate is a function that takes the key, value and source as parameters.
  If not provided, Predicate just checks the values to see if they are truthy.
  ]]

  local is_truthy = function(key, value, source)
    if value then
      return true
    else
      return false
    end
  end
  predicate = predicate or is_truthy

  for key, value in ipairs(source) do
    if not predicate(key, value, source) then
      return false
    end
  end

  return true
end

function TableUtility:any(source, predicate)
  --[[ Tests at least one items in the source is truthy.
  Predicate is a function that takes the key, value and source as parameters.
  If not provided, Predicate just checks the values to see if they are truthy.
  ]]

  local is_truthy = function(key, value, source)
    if value then
      return true
    else
      return false
    end
  end
  predicate = predicate or is_truthy

  for key, value in ipairs(source) do
    if predicate(key, value, source) then
      return true
    end
  end

  return false
end

function TableUtility:equivalent(left, right)
  --[[ Given two tables, return true if they are the same size and the elements are equivalent.
  Order matters.
  ]]

  -- Equivalent tables are the same length.
  if TableUtility:size(left) ~= TableUtility:size(right) then
    return false
  end

  local equivalentComp = function (key, value, source)
    -- Get the target value
    local target_value = right[key]

    -- Make sure the values are the same type
    if type(value) ~= type(target_value) then return false end

    -- If they are tables, recurse
    if type(value) == 'table' then
      return TableUtility:equivalent(value, target_value)
    else
      return value == right[key]
    end
  end

  local matching = TableUtility:map(left, equivalentComp)

  return TableUtility:all(matching)
end

-- Any

return TableUtility
